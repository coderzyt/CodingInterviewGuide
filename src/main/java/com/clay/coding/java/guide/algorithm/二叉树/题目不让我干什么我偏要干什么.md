### 一、题目描述

这是力扣第 341 题「 [扁平化嵌套列表迭代器](https://leetcode.cn/problems/flatten-nested-list-iterator/)」，我来描述一下题目：

首先，现在有一种数据结构 `NestedInteger`， **这个结构中存的数据可能是一个 `Integer` 整数，也可能是一个 `NestedInteger` 列表** 。注意，这个列表里面装着的是 `NestedInteger`，也就是说这个列表中的每一个元素可能是个整数，可能又是个列表，这样无限递归嵌套下去……

`NestedInteger` 有如下 API：

```java
public classNestedInteger{
    // 如果其中存的是一个整数，则返回 true，否则返回 false
    publicbooleanisInteger();

    // 如果其中存的是一个整数，则返回这个整数，否则返回 null
    public Integer getInteger();

    // 如果其中存的是一个列表，则返回这个列表，否则返回 null
    public List<NestedInteger>getList();
}
```

我们的算法会被输入一个 `NestedInteger` 列表，我们需要做的就是写一个迭代器类，将这个带有嵌套结构 `NestedInteger` 的列表「拍平」：

```java
public classNestedIteratorimplements Iterator<Integer>{
    // 构造器输入一个 NestedInteger 列表
    publicNestedIterator(List<NestedInteger> nestedList){}
  
    // 返回下一个整数
    public Integer next(){}

    // 是否还有下一个元素？
    publicbooleanhasNext(){}
}
```

我们写的这个类会被这样调用， **先调用 `hasNext` 方法，后调用 `next` 方法** ：

```java
NestedIterator i = new NestedIterator(nestedList);
while (i.hasNext())
    print(i.next());
```

[![](https://labuladong.gitee.io/algo/images/nestedList/title.jpg)](https://labuladong.gitee.io/algo/images/nestedList/title.jpg)

比如示例 1，输入的列表里有三个 `NestedInteger`，两个列表型的 `NestedInteger` 和一个整数型的 `NestedInteger`。

学过设计模式的朋友应该知道，迭代器也是设计模式的一种，目的就是为调用者屏蔽底层数据结构的细节，简单地通过 `hasNext` 和 `next` 方法有序地进行遍历。

为什么说这个题目很有启发性呢？因为我最近在用一款类似印象笔记的软件，叫做 Notion（挺有名的）。这个软件的一个亮点就是「万物皆 block」，比如说标题、页面、表格都是 block。有的 block 甚至可以无限嵌套，这就打破了传统笔记本「文件夹」->「笔记本」->「笔记」的三层结构。

回想这个算法问题，`NestedInteger` 结构实际上也是一种支持无限嵌套的结构，而且可以同时表示整数和列表两种不同类型，我想 Notion 的核心数据结构 block 估计也是这样的一种设计思路。

那么话说回来，对于这个算法问题，我们怎么解决呢？`NestedInteger` 结构可以无限嵌套，怎么把这个结构「打平」，为迭代器的调用者屏蔽底层细节，得到扁平化的输出呢？


## 基本思路

题目专门说不要尝试实现或者猜测 `NestedInteger` 的实现，那我们就立即实现一下 `NestedInteger` 的结构：

```java
public class NestedInteger {
    private Integer val;
    private List<NestedInteger> list;

    public NestedInteger(Integer val) {
        this.val = val;
        this.list = null;
    }
    public NestedInteger(List<NestedInteger> list) {
        this.list = list;
        this.val = null;
    }

    // 如果其中存的是一个整数，则返回 true，否则返回 false
    public boolean isInteger() {
        return val != null;
    }

    // 如果其中存的是一个整数，则返回这个整数，否则返回 null
    public Integer getInteger() {
        return this.val;
    }

    // 如果其中存的是一个列表，则返回这个列表，否则返回 null
    public List<NestedInteger> getList() {
        return this.list;
    }
}
```

根据 [学习数据结构和算法的框架思维](https://labuladong.github.io/article/fname.html?fname=%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E9%AB%98%E6%95%88%E6%96%B9%E6%B3%95 "null")，发现这玩意儿竟然就是个多叉树的结构：

```java
class NestedInteger {
    Integer val;
    List<NestedInteger> list;
}

// 基本的 N 叉树节点
class TreeNode {
    int val;
    TreeNode[] children;
}
```

![](https://labuladong.github.io/algo/images/nestedList/1.jpeg)

 **所以，把一个 `NestedInteger` 扁平化就等价于遍历一棵 N 叉树的所有「叶子节点」** 。

用迭代器的方式来实现这个功能，就是 **调用 `hasNext` 时，如果 `nestedList` 的第一个元素是列表类型，则不断展开这个元素，直到第一个元素是整数类型** 。

**详细题解：[题目不让我干什么，我偏要干什么](https://labuladong.github.io/article/fname.html?fname=nestInteger "null")**

**标签：[二叉树](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2121994699837177859 "null")，[数据结构](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=1318892385270808576 "null")，[设计](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAxODQxMDM0Mw==&action=getalbum&album_id=2121998148662362112 "null")**

## 解法代码

```java
public class NestedIterator implements Iterator<Integer> {
    private LinkedList<NestedInteger> list;

    public NestedIterator(List<NestedInteger> nestedList) {
        // 不直接用 nestedList 的引用，是因为不能确定它的底层实现
        // 必须保证是 LinkedList，否则下面的 addFirst 会很低效
        list = new LinkedList<>(nestedList);
    }

    public Integer next() {
        // hasNext 方法保证了第一个元素一定是整数类型
        return list.remove(0).getInteger();
    }

    public boolean hasNext() {
        // 循环拆分列表元素，直到列表第一个元素是整数类型
        while (!list.isEmpty() && !list.get(0).isInteger()) {
            // 当列表开头第一个元素是列表类型时，进入循环
            List<NestedInteger> first = list.remove(0).getList();
            // 将第一个列表打平并按顺序添加到开头
            for (int i = first.size() - 1; i >= 0; i--) {
                list.addFirst(first.get(i));
            }
        }
        return !list.isEmpty();
    }
}
```
